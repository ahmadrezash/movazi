"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const hash_1 = tslib_1.__importDefault(require("./hash"));
const ignore_1 = tslib_1.__importDefault(require("ignore"));
const klaw_1 = tslib_1.__importDefault(require("klaw"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const through2_1 = tslib_1.__importDefault(require("through2"));
const path_1 = require("path");
const mode755 = 16893;
const mode644 = 33204;
const defaultIgnores = [
    '.git',
    '.idea',
    '.vscode',
    '.gitignore',
    '.liaraignore',
    '.dockerignore',
    '*.*~',
    'node_modules',
    'bower_components',
];
function trimLines(lines) {
    return lines.reduce((prev, line) => {
        if (!line.trim() || line.startsWith('#')) {
            return prev;
        }
        return [...prev, line];
    }, []);
}
const loadIgnoreFile = (ignoreInstance, ignoreFilePath, projectPath) => {
    const patterns = trimLines(fs_extra_1.default.readFileSync(ignoreFilePath).toString().split('\n'));
    const relativeToProjectPath = patterns.map((pattern) => {
        const dir = path_1.dirname(ignoreFilePath);
        if (pattern.startsWith('!')) {
            const absolutePrefix = pattern.substr(1).startsWith('/') ? '/' : '';
            return '!' + absolutePrefix + path_1.relative(projectPath, path_1.join(dir, pattern.substr(1)));
        }
        const absolutePrefix = pattern.startsWith('/') ? '/' : '';
        return absolutePrefix + path_1.relative(projectPath, path_1.join(dir, pattern));
    });
    ignoreInstance.add(relativeToProjectPath);
};
function addIgnorePatterns(ignoreInstance, projectPath) {
    return through2_1.default.obj(function (item, _, next) {
        const liaraignorePath = path_1.join(path_1.dirname(item.path), '.liaraignore');
        const dockerignorePath = path_1.join(path_1.dirname(item.path), '.dockerignore');
        const gitignorePath = path_1.join(path_1.dirname(item.path), '.gitignore');
        if (fs_extra_1.default.existsSync(liaraignorePath)) {
            loadIgnoreFile(ignoreInstance, liaraignorePath, projectPath);
        }
        else if (fs_extra_1.default.existsSync(dockerignorePath)) {
            loadIgnoreFile(ignoreInstance, dockerignorePath, projectPath);
        }
        else if (fs_extra_1.default.existsSync(gitignorePath)) {
            loadIgnoreFile(ignoreInstance, gitignorePath, projectPath);
        }
        this.push(item);
        return next();
    });
}
function ignoreFiles(ignoreInstance, projectPath, debug) {
    return through2_1.default.obj(function (item, _, next) {
        const itemPath = path_1.relative(projectPath, item.path);
        if (itemPath) {
            if (!ignoreInstance.ignores(itemPath)) {
                this.push(item);
            }
            else {
                debug(`ignoring ${item.path.replace(path_1.resolve(projectPath) + '/', '')}`);
            }
        }
        return next();
    });
}
async function getFileMode(path) {
    try {
        // Is executable?
        await fs_extra_1.default.access(path, fs_extra_1.default.constants.X_OK);
        return mode755;
    }
    catch (_a) {
        // File is not executable.
        return mode644;
    }
}
async function getFiles(projectPath, debug = () => { }) {
    const mapHashesToFiles = new Map();
    const directories = [];
    const ignoreInstance = ignore_1.default({ ignorecase: false });
    ignoreInstance.add(defaultIgnores);
    await new Promise(resolve => {
        let tmpFiles = [];
        klaw_1.default(projectPath)
            .pipe(addIgnorePatterns(ignoreInstance, projectPath))
            .pipe(ignoreFiles(ignoreInstance, projectPath, debug))
            .on('data', (file) => tmpFiles.push(file))
            .on('end', async () => {
            await Promise.all(tmpFiles.map(async ({ path, stats }) => {
                const filePath = path_1.relative(projectPath, path);
                if (!stats.isFile()) {
                    const dir = {
                        mode: mode755,
                        path: filePath,
                    };
                    return directories.push(dir);
                }
                const data = await fs_extra_1.default.readFile(path);
                const checksum = hash_1.default(data);
                const file = {
                    checksum,
                    path: filePath,
                    size: stats.size,
                    mode: await getFileMode(filePath),
                };
                if (mapHashesToFiles.has(checksum)) {
                    const item = mapHashesToFiles.get(checksum);
                    if (!item)
                        return;
                    mapHashesToFiles.set(checksum, {
                        data,
                        files: [...item.files, file],
                    });
                }
                else {
                    mapHashesToFiles.set(checksum, {
                        data,
                        files: [file],
                    });
                }
            }));
            resolve();
        });
    });
    // flatten files
    const files = Array
        .from(mapHashesToFiles)
        // tslint:disable-next-line: no-unused
        .reduce((prevFiles, [_, mapItem]) => {
        return [
            ...prevFiles,
            ...mapItem.files,
        ];
    }, []);
    return { files, directories, mapHashesToFiles };
}
exports.default = getFiles;
