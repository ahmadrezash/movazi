"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os_1 = tslib_1.__importDefault(require("os"));
const ora_1 = tslib_1.__importDefault(require("ora"));
const path_1 = tslib_1.__importDefault(require("path"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const bytes_1 = tslib_1.__importDefault(require("bytes"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const moment_1 = tslib_1.__importDefault(require("moment"));
const request_1 = tslib_1.__importDefault(require("request"));
const inquirer_1 = tslib_1.__importDefault(require("inquirer"));
const async_retry_1 = tslib_1.__importDefault(require("async-retry"));
const archiver_1 = tslib_1.__importDefault(require("archiver"));
const progress_1 = tslib_1.__importDefault(require("progress"));
const command_1 = require("@oclif/command");
const logs_1 = tslib_1.__importDefault(require("./logs"));
const base_1 = tslib_1.__importDefault(require("../base"));
const poller_1 = tslib_1.__importDefault(require("../utils/poller"));
const constants_1 = require("../constants");
const get_port_1 = tslib_1.__importDefault(require("../utils/get-port"));
const check_path_1 = tslib_1.__importDefault(require("../utils/check-path"));
const on_intrupt_1 = tslib_1.__importDefault(require("../utils/on-intrupt"));
const get_files_1 = tslib_1.__importDefault(require("../utils/get-files"));
const validate_port_1 = tslib_1.__importDefault(require("../utils/validate-port"));
const output_1 = require("../utils/output");
const detect_platform_1 = tslib_1.__importDefault(require("../utils/detect-platform"));
require('follow-redirects').maxBodyLength = 200 * 1024 * 1024; // 200 MB
class Deploy extends base_1.default {
    async run() {
        const { flags } = this.parse(Deploy);
        const config = this.getMergedConfig(flags);
        const debug = output_1.createDebugLogger(flags.debug);
        this.debug = debug;
        this.spinner = ora_1.default();
        this.debug();
        try {
            check_path_1.default(config.path);
        }
        catch (error) {
            this.error(error.message);
        }
        this.dontDeployEmptyProjects(config.path);
        this.setAxiosToken(config);
        this.validateDeploymentConfig(config);
        let isPlatformDetected = false;
        if (!config.image) {
            if (!config.platform) {
                try {
                    config.platform = detect_platform_1.default(config.path);
                    isPlatformDetected = true;
                }
                catch (error) {
                    return this.error(error.message);
                }
            }
            this.validatePlatform(config.platform, config.path);
        }
        else {
            config.platform = 'docker';
        }
        if (!config.project) {
            config.project = await this.promptProject();
        }
        if (!config.port) {
            config.port = get_port_1.default(config.platform) || await this.promptPort();
        }
        this.logKeyValue('Project', config.project);
        this.logKeyValue('Path', config.path);
        isPlatformDetected
            ? this.logKeyValue('Detected platform', config.platform)
            : this.logKeyValue('Platform', config.platform);
        this.logKeyValue('Port', String(config.port));
        try {
            const response = await this.deploy(config);
            if (!response || !response.data) {
                return this.error(`deploy: ${JSON.stringify(response)}`);
            }
            !config.image && await this.showBuildLogs(response.data.releaseID);
            config.image && await this.showReleaseLogs(response.data.releaseID);
            this.log();
            this.log(chalk_1.default.green('Deployment finished successfully.'));
            this.log(chalk_1.default.white('Open up the url below in your browser:'));
            this.log();
            constants_1.DEV_MODE
                // tslint:disable-next-line: no-http-string
                ? this.log(`    ${chalk_1.default.cyan(`http://${config.project}.liara.localhost`)}`)
                : this.log(`    ${chalk_1.default.cyan(`https://${config.project}.liara.run`)}`);
            this.log();
            if (!flags['no-project-logs']) {
                this.log('Reading project logs...');
                await logs_1.default.run(['--project', config.project, '--since', moment_1.default().unix().toString()]);
            }
        }
        catch (error) {
            this.log();
            this.spinner.stop();
            error.response && debug(JSON.stringify(error.response.data));
            if (error.message === 'TIMEOUT') {
                this.error('Build timed out. It took about 10 minutes.');
            }
            this.error(`Deployment failed.
Sorry for inconvenience. Please contact us.`);
        }
    }
    async deploy(config) {
        const body = {
            port: config.port,
            type: config.platform,
            mountPoint: config.volume,
        };
        if (config.image) {
            body.image = config.image;
            return this.createRelease(config.project, body);
        }
        this.spinner.start('Collecting project files...');
        const { files, directories, mapHashesToFiles } = await get_files_1.default(config.path, this.debug);
        this.spinner.stop();
        body.files = files;
        body.directories = directories;
        const retryOptions = {
            onRetry: (error) => {
                this.debug(`Retrying due to: ${error.message}`);
                if (error.response) {
                    this.debug(JSON.stringify(error.response.data));
                }
                else {
                    this.debug(error.stack);
                }
            },
        };
        return async_retry_1.default(async (bail) => {
            try {
                return await this.createRelease(config.project, body);
            }
            catch (error) {
                const { response } = error;
                if (!response)
                    throw error; // Retry deployment
                if (response.status === 400 && response.data.message === 'frozen_project') {
                    this.error(`Project is frozen (not enough balance).
  Please open up https://console.liara.ir/projects and unfreeze the project.`);
                }
                if (response.status === 400 && response.data.message === 'missing_files') {
                    const { missingFiles } = response.data.data;
                    this.spinner.start(`Files to upload: ${missingFiles.length}`);
                    await this.uploadMissingFiles(mapHashesToFiles, missingFiles);
                    throw error; // Retry deployment
                }
                return bail(error);
            }
        }, retryOptions);
    }
    createRelease(project, body) {
        return axios_1.default.post(`/v2/projects/${project}/releases`, body, this.axiosConfig);
    }
    async showBuildLogs(releaseID) {
        this.spinner.start('Building...');
        let isCanceled = false;
        const removeInterupListener = on_intrupt_1.default(async () => {
            // Force close
            if (isCanceled)
                process.exit(3);
            this.spinner.start('\nCanceling the build...');
            isCanceled = true;
            const retryOptions = {
                retries: 3,
                onRetry: (error, attempt) => {
                    this.debug(error.stack);
                    this.log(`${attempt}: Could not cancel, retrying...`);
                }
            };
            await async_retry_1.default(async () => {
                await axios_1.default.post(`/v2/releases/${releaseID}/cancel`, null, this.axiosConfig);
            }, retryOptions);
            this.spinner.warn('Build canceled.');
            process.exit(3);
        });
        return new Promise((resolve, reject) => {
            const poller = new poller_1.default();
            let since;
            let isDeploying = false;
            poller.onPoll(async () => {
                try {
                    const { data: { release, buildOutput } } = await axios_1.default.get(`/v2/releases/${releaseID}/build-logs`, Object.assign({}, this.axiosConfig, { params: { since } }));
                    for (const output of buildOutput) {
                        this.spinner.clear().frame();
                        if (output.stream === 'STDOUT') {
                            process.stdout.write(output.line);
                        }
                        else {
                            // tslint:disable-next-line: no-console
                            console.error(output.line);
                            return reject(new Error('Build failed.'));
                        }
                    }
                    if (!buildOutput.length) {
                        if (release.state === 'CANCELED') {
                            this.spinner.warn('Build canceled.');
                            process.exit(3);
                        }
                        if (release.state === 'TIMEDOUT') {
                            return reject(new Error('TIMEOUT'));
                        }
                        if (release.state === 'FAILED') {
                            return reject(new Error('Release failed.'));
                        }
                        if (release.state === 'DEPLOYING' && !isDeploying) {
                            isDeploying = true;
                            this.spinner.succeed('Image pushed.');
                            this.spinner.start('Creating a new release...');
                        }
                        if (release.state === 'READY') {
                            this.spinner.succeed('Release created.');
                            return resolve();
                        }
                    }
                    if (buildOutput.length) {
                        const lastLine = buildOutput[buildOutput.length - 1];
                        since = lastLine.createdAt;
                        if (lastLine.line.startsWith('Successfully tagged')) {
                            this.spinner.succeed('Build finished.');
                            this.spinner.start('Pushing the image...');
                            removeInterupListener();
                        }
                    }
                }
                catch (error) {
                    this.debug(error.stack);
                }
                !isCanceled && poller.poll();
            });
            !isCanceled && poller.poll();
        });
    }
    async showReleaseLogs(releaseID) {
        this.spinner.start('Creating a new release...');
        return new Promise(resolve => {
            const poller = new poller_1.default();
            poller.onPoll(async () => {
                try {
                    const { data: { release } } = await axios_1.default.get(`/v1/releases/${releaseID}`, this.axiosConfig);
                    if (release.state === 'READY') {
                        this.spinner.succeed('Release created.');
                        return resolve();
                    }
                }
                catch (error) {
                    this.debug(error.stack);
                }
                poller.poll();
            });
            poller.poll();
        });
    }
    dontDeployEmptyProjects(projectPath) {
        if (fs_extra_1.default.readdirSync(projectPath).length === 0) {
            this.error('Project is empty!');
        }
    }
    logKeyValue(key, value) {
        this.spinner.clear().frame();
        this.log(`${chalk_1.default.gray(`${key}:`)} ${value}`);
    }
    setAxiosToken(config) {
        if (!config['api-token']) {
            return;
        }
        this.axiosConfig.headers.Authorization = `Bearer ${config['api-token']}`;
    }
    validateDeploymentConfig(config) {
        if (config.volume && !path_1.default.isAbsolute(config.volume)) {
            this.error('Volume path must be absolute.');
        }
    }
    async promptProject() {
        this.spinner.start('Loading...');
        try {
            const { data: { projects } } = await axios_1.default.get('/v1/projects', this.axiosConfig);
            this.spinner.stop();
            if (!projects.length) {
                this.warn('Please go to https://console.liara.ir/projects and create a project, first.');
                this.exit(1);
            }
            const { project } = await inquirer_1.default.prompt({
                name: 'project',
                type: 'list',
                message: 'Please select a project:',
                choices: [
                    ...projects.map(project => project.project_id),
                ]
            });
            return project;
        }
        catch (error) {
            this.spinner.stop();
            throw error;
        }
    }
    async promptPort() {
        const { port } = await inquirer_1.default.prompt({
            name: 'port',
            type: 'input',
            default: 3000,
            message: 'Enter the port your app listens to:',
            validate: validate_port_1.default,
        });
        return port;
    }
    getMergedConfig(flags) {
        const defaults = Object.assign({ path: flags.path ? flags.path : process.cwd() }, this.readGlobalConfig());
        const projectConfig = this.readProjectConfig(defaults.path);
        return Object.assign({}, defaults, projectConfig, flags);
    }
    readProjectConfig(projectPath) {
        let content;
        const liaraJSONPath = path_1.default.join(projectPath, 'liara.json');
        const hasLiaraJSONFile = fs_extra_1.default.existsSync(liaraJSONPath);
        if (hasLiaraJSONFile) {
            try {
                content = fs_extra_1.default.readJSONSync(liaraJSONPath) || {};
            }
            catch (_a) {
                this.error('Syntax error in `liara.json`!');
            }
        }
        return content || {};
    }
    validatePlatform(platform, projectPath) {
        if (platform === 'node') {
            const packageJSON = fs_extra_1.default.readJSONSync(path_1.default.join(projectPath, 'package.json'));
            if (!packageJSON.scripts || !packageJSON.scripts.start) {
                this.error(`A NodeJS project must be runnable with 'npm start'.
You must add a 'start' command to your package.json scripts.`);
            }
        }
    }
    async uploadMissingFiles(mapHashesToFiles, missingFiles) {
        const archive = archiver_1.default('tar', {
            gzip: true,
            gzipOptions: { level: 9 },
        });
        archive.on('error', (error) => {
            this.debug(error);
            throw error;
        });
        for (const hash of missingFiles) {
            const mapItem = mapHashesToFiles.get(hash);
            mapItem && archive.append(mapItem.data, { name: hash });
        }
        archive.finalize();
        const tmpArchivePath = path_1.default.join(os_1.default.tmpdir(), `${Date.now()}.tar.gz`);
        const archiveSize = await new Promise((resolve, reject) => {
            archive.pipe(fs_extra_1.default.createWriteStream(tmpArchivePath))
                .on('error', reject)
                .on('close', function () {
                const { size } = fs_extra_1.default.statSync(tmpArchivePath);
                resolve(size);
            });
        });
        this.logKeyValue('Compressed size', bytes_1.default(archiveSize));
        const tmpArchiveStream = fs_extra_1.default.createReadStream(tmpArchivePath);
        const bar = new progress_1.default('Uploading [:bar] :rate/bps :percent :etas', { total: archiveSize });
        return new Promise(resolve => {
            const req = request_1.default.post({
                url: '/v1/files/archive',
                baseUrl: this.axiosConfig.baseURL,
                // @ts-ignore
                data: tmpArchiveStream,
                headers: {
                    Authorization: this.axiosConfig.headers.Authorization,
                },
            });
            const interval = setInterval(() => {
                bar.tick(req.req.connection._bytesDispatched - bar.curr);
                if (bar.complete) {
                    this.spinner.succeed('Upload finished.');
                    this.spinner.start('Extracting...');
                    clearInterval(interval);
                }
            }, 250);
            tmpArchiveStream.pipe(req)
                .on('response', async () => {
                this.spinner.succeed('Extract finished.');
                fs_extra_1.default.unlink(tmpArchivePath)
                    .then(() => { })
                    .catch(() => { });
                resolve();
            });
        });
    }
}
Deploy.description = 'deploy a project';
Deploy.flags = Object.assign({}, base_1.default.flags, { path: command_1.flags.string({ description: 'project path in your computer' }), platform: command_1.flags.string({ description: 'the platform your project needs to run' }), project: command_1.flags.string({ char: 'p', description: 'project id' }), port: command_1.flags.integer({ description: 'the port that your app listens to' }), volume: command_1.flags.string({ char: 'v', description: 'volume absolute path' }), image: command_1.flags.string({ char: 'i', description: 'docker image to deploy' }), 'no-project-logs': command_1.flags.boolean({ description: 'do not stream project logs after deployment', default: false }) });
exports.default = Deploy;
