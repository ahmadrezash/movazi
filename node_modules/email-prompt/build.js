var ansi = require('ansi-escapes')
var chalk = require('chalk')

// eslint-disable-next-line no-multi-assign
module.exports = exports.default = function emailPrompt(ref) {
  if ( ref === void 0 ) ref = {};
  var start = ref.start; if ( start === void 0 ) start = '> Enter your email: ';
  var domains = ref.domains; if ( domains === void 0 ) domains = new Set([
    'aol.com',
    'gmail.com',
    'google.com',
    'yahoo.com',
    'ymail.com',
    'hotmail.com',
    'live.com',
    'outlook.com',
    'inbox.com',
    'mail.com',
    'gmx.com',
    'icloud.com',
    'zeit.co'
  ]);
  var forceLowerCase = ref.forceLowerCase; if ( forceLowerCase === void 0 ) forceLowerCase = true;
  var suggestionColor = ref.suggestionColor; if ( suggestionColor === void 0 ) suggestionColor = 'gray';
  var autoCompleteChars = ref.autoCompleteChars; if ( autoCompleteChars === void 0 ) autoCompleteChars = new Set([
    '\t' /* tab */,
    '\r' /* return */,
    '\x1b[C' /* right arrow */,
    ' ' /* Spacebar */
  ]);
  var resolveChars = ref.resolveChars; if ( resolveChars === void 0 ) resolveChars = new Set(['\r']);
  var abortChars = ref.abortChars; if ( abortChars === void 0 ) abortChars = new Set(['\x03']);
  var allowInvalidChars = ref.allowInvalidChars; if ( allowInvalidChars === void 0 ) allowInvalidChars = false;

  return new Promise(function (resolve, reject) {
    // Some environments (e.g., cygwin) don't provide a tty
    if (!process.stdin.setRawMode) {
      return reject(new Error('stdin lacks setRawMode support'))
    }

    var isRaw = process.stdin.isRaw

    process.stdout.write(start)
    process.stdin.setRawMode(true)
    process.stdin.resume()

    var val = ''
    var suggestion = ''
    var caretOffset = 0

    // To make `for..of` work with buble
    var _domains = Array.from(domains)

    var ondata = function (v) {
      var s = v.toString()

      // Abort upon ctrl+C
      if (abortChars.has(s)) {
        restore()
        return reject(new Error('User abort'))
      }

      var completion = ''

      // If we have a suggestion *and*
      // the user is at the end of the line *and*
      // the user pressed one of the keys to trigger completion
      if (suggestion !== '' && !caretOffset && autoCompleteChars.has(s)) {
        val += suggestion
        suggestion = ''
      } else {
        if (s === '\x1b[D') {
          if (val.length > Math.abs(caretOffset)) {
            caretOffset--
          }
        } else if (s === '\x1b[C') {
          if (caretOffset < 0) {
            caretOffset++
          }
        } else if (s === '\x08' || s === '\x7f') {
          // Delete key needs splicing according to caret position
          val = val.substr(0, val.length + caretOffset - 1) +
            val.substr(val.length + caretOffset)
        } else {
          if (resolveChars.has(s)) {
            restore()
            return resolve(val)
          }

          if (!allowInvalidChars) {
            // Disallow more than one @
            if (/@/.test(val) && s === '@') {
              return
            }

            if (/[^A-z0-9-+_.@]/.test(s)) {
              return
            }
          }

          var add = forceLowerCase ? s.toLowerCase() : s
          val = val.substr(0, val.length + caretOffset) + add +
            val.substr(val.length + caretOffset)
        }

        var parts = val.split('@')
        if (parts.length === 2 && parts[1].length > 0) {
          var _host = parts[1];
          var host = _host.toLowerCase()
          for (var i = 0, list = _domains; i < list.length; i += 1) {
            var domain = list[i];

            if (host === domain) {
              break
            }

            if (host === domain.substr(0, host.length)) {
              suggestion = domain.substr(host.length)
              completion = chalk[suggestionColor](suggestion)
              completion += ansi.cursorBackward(domain.length - host.length)
              break
            }
          }
        }

        if (completion.length === 0) {
          suggestion = ''
        }
      }

      process.stdout.write(ansi.eraseLines(1) + start + val + completion)
      if (caretOffset) {
        process.stdout.write(ansi.cursorBackward(Math.abs(caretOffset)))
      }
    }

    var restore = function () {
      process.stdin.setRawMode(isRaw)
      process.stdin.pause()
      process.stdin.removeListener('data', ondata)
    }

    process.stdin.on('data', ondata)
  })
}

